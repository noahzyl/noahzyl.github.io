[{"content":"LeetCode203 移除链表元素 1.题目描述 给你一个链表的头节点head和一个整数val，请你删除链表中所有满足Node.val == val的节点，并返回新的头节点。\n示例 1：\n1 2 输入： head = [1,2,6,3,4,5,6], val = 6 输出： [1,2,3,4,5] 示例 2：\n1 2 输入： head = [], val = 1 输出： [] 示例 3：\n1 2 输入： head = [7,7,7,7], val = 7 输出： [] 提示：\n列表中的节点数目在范围 [0, 10^4] 内 1 \u0026lt;= Node.val \u0026lt;= 50 0 \u0026lt;= val \u0026lt;= 50 2.算法分析 这是一道考察单链表删除结点操作的题目，没有特别的算法，关键是要了解单链表的逻辑结构。删除单链表结点的核心是：找到待删除结点的前一个结点。\n此外，为了统一操作，我将使用虚拟头结点（有时也被称为空头结点）。\n3.解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeElements(head *ListNode, val int) *ListNode { dummy_head := new(ListNode) // 虚拟头结点 dummy_head.Next = head cur := dummy_head // 用于操作的临时指针 // 当cur.Next为空指针时，cur就是链表中的最后一个结点 for cur.Next != nil { // 在删除结点后，cur需要保持在原位，以处理连续出现多个目标结点的情形 if cur.Next.Val == val { cur.Next = cur.Next.Next } else { cur = cur.Next } } return dummy_head.Next // 返回实际的头指针 } LeetCode707 设计链表 1.题目描述 你可以选择使用单链表或者双链表，设计并实现自己的链表。\n单链表中的节点应该具备两个属性：val和next。val是当前节点的值，next是指向下一个节点的指针/引用。\n如果是双向链表，则还需要属性prev以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。\n实现MyLinkedList类：\nMyLinkedList()初始化MyLinkedList对象。 int get(int index)获取链表中下标为index的节点的值。如果下标无效，则返回-1。 void addAtHead(int val)将一个值为val的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。 void addAtTail(int val)将一个值为val的节点追加到链表中作为链表的最后一个元素。 void addAtIndex(int index, int val)将一个值为val的节点插入到链表中下标为index的节点之前。如果index等于链表的长度，那么该节点会被追加到链表的末尾。如果index比长度更大，该节点将不会插入到链表中。 void deleteAtIndex(int index)如果下标有效，则删除链表中下标为index的节点。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 输入 [\u0026#34;MyLinkedList\u0026#34;, \u0026#34;addAtHead\u0026#34;, \u0026#34;addAtTail\u0026#34;, \u0026#34;addAtIndex\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;deleteAtIndex\u0026#34;, \u0026#34;get\u0026#34;] [[], [1], [3], [1, 2], [1], [1], [1]] 输出 [null, null, null, null, 2, null, 3] 解释 MyLinkedList myLinkedList = new MyLinkedList(); myLinkedList.addAtHead(1); myLinkedList.addAtTail(3); myLinkedList.addAtIndex(1, 2); // 链表变为 1-\u0026gt;2-\u0026gt;3 myLinkedList.get(1); // 返回 2 myLinkedList.deleteAtIndex(1); // 现在，链表变为 1-\u0026gt;3 myLinkedList.get(1); // 返回 3 提示：\n0 \u0026lt;= index, val \u0026lt;= 1000 请不要使用内置的 LinkedList 库。 调用 get、addAtHead、addAtTail、addAtIndex 和 deleteAtIndex 的次数不超过 2000 。 2.算法分析 这道题同样考察的是链表的基本操作，都不难，只需要注意以下几点即可：\n按索引获取结点值需要找到索引对应的结点； 尾部添加结点需要将临时指针初始化指向虚拟头结点，因为链表可能为空，此时直接在虚拟头结点后插入新结点； 按索引添加或删除元素需要找到索引对应结点的前一个结点，也正因如此，需要将临时指针初始化指向虚拟头结点； 按索引添加元素时，索引可以恰好等于链表的长度，这相当于在链表尾部添加新结点。 3.解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 type MyLinkedList struct { dummy_head *ListNode size int } func Constructor() MyLinkedList { return MyLinkedList{dummy_head: new(ListNode), size: 0} } func (this *MyLinkedList) Get(index int) int { if index \u0026lt; 0 || index \u0026gt; this.size - 1 { return -1 } cur := this.dummy_head.Next for n := 0; n \u0026lt; index; n++ { cur = cur.Next } return cur.Val } func (this *MyLinkedList) AddAtHead(val int) { new_node := \u0026amp;ListNode{Val: val} new_node.Next = this.dummy_head.Next this.dummy_head.Next = new_node this.size++ } func (this *MyLinkedList) AddAtTail(val int) { new_node := \u0026amp;ListNode{Val: val} cur := this.dummy_head for cur.Next != nil { cur = cur.Next } cur.Next = new_node this.size++ } func (this *MyLinkedList) AddAtIndex(index int, val int) { if index \u0026lt; 0 || index \u0026gt; this.size { return } new_node := \u0026amp;ListNode{Val: val} cur := this.dummy_head for n := 0; n \u0026lt; index; n++ { cur = cur.Next } new_node.Next = cur.Next cur.Next = new_node this.size++ } func (this *MyLinkedList) DeleteAtIndex(index int) { if index \u0026lt; 0 || index \u0026gt; this.size - 1 { return } cur := this.dummy_head for n := 0; n \u0026lt; index; n++ { cur = cur.Next } cur.Next = cur.Next.Next this.size-- } LeetCode206 反转链表 1.题目描述 给你单链表的头节点head，请你反转链表，并返回反转后的链表。\n示例 1：\n1 2 输入： head = [1,2,3,4,5] 输出： [5,4,3,2,1] 示例 2：\n1 2 输入： head = [1,2] 输出： [2,1] 示例 3：\n1 2 输入： head = [] 输出： [] 提示：\n链表中节点的数目范围是 [0, 5000] -5000 \u0026lt;= Node.val \u0026lt;= 5000 进阶： 链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\n2.算法分析 由于这道题不要求必须使用原位算法，因此可以创建一个新链表并使用循环在头部插入结点的方式来实现链表的反转，称之为头插法。\n如果需要实现原位反转，则可以考虑使用双指针法或递归法。\n双指针法： 实际上，实现链表的反转，只需要让链表中所有结点的Next指向反转即可，因此，可以用cur指针指向当前结点，用pre指针指向cur的前一个结点，通过cur.Next = pre就可以实现指向的反转。不过需要注意的是，由于cur.Next = pre后cur的下一个位置会丢失，因此需要用一个临时指针来保存cur的下一位置，以使得cur能正常遍历链表。\n递归法： 递归法的思想和双指针法是一样的，都是直接反转所有结点的Next的指向，只是将双指针法中循环遍历反转链表的过程用递归调用来实现。\n3.解题代码 头插法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { if head == nil { return head // 当head为空指针时，链表为空，不需要反转 } else { dummy_head := new(ListNode) // 虚拟头结点 cur := head // 用于遍历原链表的临时指针 for cur.Next != nil { node := \u0026amp;ListNode{Val: cur.Val} node.Next = dummy_head.Next dummy_head.Next = node cur = cur.Next } // 处理余下的最后一个结点 last_node := \u0026amp;ListNode{Val: cur.Val} last_node.Next = dummy_head.Next dummy_head.Next = last_node return dummy_head.Next // 返回反转后的实际头结点 } } 双指针法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { cur := head var pre *ListNode = nil // 由于head反转后是尾结点，因此head反转后指向的是空指针 // 当cur为空指针时，pre恰好指向反转后链表的头结点，此时反转结束 for cur != nil { temp := cur.Next // 用临时指针保存cur的下一个位置 cur.Next = pre // 反转Next的指向 // 移动两个指针，注意必须先移动pre，否则cur的当前位置会丢失 pre = cur cur = temp } return pre // 反转结束后，pre指向的是反转后链表的头结点 } 递归法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverse(cur *ListNode, pre *ListNode) *ListNode { // 当cur为空指针时，pre指向反转后链表的头结点，反转结束 if cur == nil { return pre } temp := cur.Next // 用临时指针保存cur的下一位置 cur.Next = pre // 反转Next的指向 return reverse(temp, cur) // 将cur和pre的下一位置传给下一层函数 } func reverseList(head *ListNode) *ListNode { // cur的初始值为head，pre的初始值为空指针 return reverse(head, (*ListNode)(nil)) } ","date":"2025-03-21T23:32:19+08:00","permalink":"https://noahzyl.github.io/p/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-3leetcode203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0leetcode707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8leetcode206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","title":"算法训练 3｜LeetCode203 移除链表元素、LeetCode707 设计链表、LeetCode206 反转链表"},{"content":"209 长度最小的子数组 1.题目描述 给定一个含有 n 个正整数的数组和一个正整数 target。找出该数组中满足其总和大于等于 target 的长度最小的子数组[numsl, numsl+1, ..., numsr-1, numsr]，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n示例 1：\n1 2 3 输入： target = 7, nums = [2,3,1,2,4,3] 输出： 2 解释： 子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2：\n1 2 输入： target = 4, nums = [1,4,4] 输出： 1 示例 3：\n1 2 输入： target = 11, nums = [1,1,1,1,1,1,1,1] 输出： 0 提示：\n1 \u0026lt;= target \u0026lt;= 10^9 1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^4 2.算法分析 从直觉上说，这道题可以用时间复杂度为$O(n^2)$的暴力算法解决，即用两层for循环，外层循环用于遍历数组中的元素，内层循环用于从某个元素开始进行累计求和，寻找满足条件的子数组。暴力算法的代码实现为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int minSubArrayLen(int target, int[] nums) { int minLen = 0; for(int i = 0; i \u0026lt; nums.length; i++) { int sum = 0; int j = i; for(; j \u0026lt; nums.length; j++) { sum += nums[j]; if(sum \u0026gt;= target) { break; } } if(sum \u0026gt;= target) { if(minLen == 0 || (minLen \u0026gt; 0 \u0026amp;\u0026amp; (j - i + 1) \u0026lt; minLen)) { minLen = j - i + 1; } } } return minLen; } } 但是很遗憾，由于数组长度$n$最大为$10^5$，因此使用暴力算法会出现超时。要降低时间复杂度，可以考虑使用双指针法的变种——滑动窗口法。滑动窗口法本质上还是用两个指针在一层for循环内同时完成暴力算法中两层for循环的操作，在这里就是同时完成数组元素遍历和累计求和：\nend指针表示窗口/子数组的终点； start指针表示窗口/子数组的起点。 在滑动窗口法中，首先不断向后移动end指针，在这个过程中同时完成数组元素遍历和累计求和操作，当窗口内的元素和大于等于目标值时，就将start当前位置的元素值从累计和中减去，并将start向后移，缩小窗口大小，以寻找最小窗口（因为题目要求寻找最小子数组）。注意到和暴力算法不同的是，此处不需要重新遍历一次窗口，只需要从累计和中减去start所处位置的元素值即可计算出新窗口内的元素和，这也是滑动窗口法降低时间复杂度的奥秘所在。\n3.解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int minSubArrayLen(int target, int[] nums) { int start = 0; int sum = 0; int result = 0; for(int end = 0; end \u0026lt; nums.length; end++) { sum += nums[end]; // 由于是寻找最小子数组长度，所以此处用while而不是if while(sum \u0026gt;= target) { int subLen = end - start + 1; if(result == 0) { result = subLen; } else { if(subLen \u0026lt; result) { result = subLen; } } sum -= nums[start]; start++; } } return result; } } 59 螺旋矩阵 II 1.题目描述 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n示例 1：\n1 2 输入： n = 3 输出： [[1,2,3],[8,9,4],[7,6,5]] 示例 2：\n1 2 输入： n = 1 输出： [[1]] 提示：\n1 \u0026lt;= n \u0026lt;= 20 2.算法分析 这是一道模拟题，没有什么特别的算法，主要是模拟螺旋的过程，关键在于：\n如何用代码表示螺旋的过程； 如何处理边界条件。 第一，因为目标矩阵是一个n x n的方阵，因此每一次旋转都固定处理四条边且各条边的长度相同。又因为每一次旋转后，矩阵待填充的行数会减少2，待填充的列数也会减少2，因此每一次旋转都会使得边的长度减2。并且不难看出，每次旋转的起始位置都在矩阵的主对角线上：第一次旋转的起始位置是(0,0)，第二次是(1,1)，第三次是(2,2)，以此类推。\n第二，由于矩阵的四个顶点是被两条边所共享的，因此需要设计好各个顶点是被哪条边处理。我建议每条边都处理其起始位置，将终止位置交由下一条边处理，因为上一条边的终止位置就是下一条边的起始位置。这种对于边的表示，就类似于一种左闭右开区间。在这种表示下，每一条边要处理的元素个数就是边的长度减1。\n最后需要注意一种特殊情况，当n为偶数时，经过若干次旋转，恰好可以填充完整个矩阵，而当n为奇数时，最后会剩下矩阵的中心位置，此时边长为1，也无所谓旋转，直接将值填入该位置即可。\n基于上述分析，就可以写出模拟螺旋的代码了。\n3.解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public int[][] generateMatrix(int n) { int[][] matrix = new int[n][n]; int val = 1; int count = 0;// 记录旋转的次数，用于表示旋转的起始位置 // 初始边长为n，每一次旋转后边长减2 for(int len = n; len \u0026gt; 0; len -= 2) { int i = count;// 旋转起始位置的行索引 int j = count;// 旋转起始位置的列索引 if(len == 1) {// 处理n为奇数时最后剩下的中心位置 matrix[i][j] = val; } else { // 第一条边 for(; j \u0026lt; count + len - 1; j++) { matrix[i][j] = val; val++; } // 第二条边 for(; i \u0026lt; count + len - 1; i++) { matrix[i][j] = val; val++; } // 第三条边 // 循环开始时，j为count + len - 1，又因为要处理len - 1个元素， // 所以循环条件是j \u0026gt; count，下同 for(; j \u0026gt; count; j--) { matrix[i][j] = val; val++; } // 第四条边 for(; i \u0026gt; count; i--) { matrix[i][j] = val; val++; } } count++; } return matrix; } } 区间和 1.题目描述 给定一个整数数组Array，请计算该数组在每个指定区间内元素的总和。\n输入描述\n第一行输入为整数数组Array的长度n，接下来n行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间下标a，b（b \u0026gt;= a），直至文件结束。\n输出描述\n输出每个指定区间内元素的总和。\n输入示例\n1 2 3 4 5 6 7 8 5 1 2 3 4 5 0 1 1 3 输出示例\n1 2 3 9 提示信息\n0 \u0026lt; n \u0026lt;= 100000\n题目链接：58.区间和｜代码随想录\n2.算法分析 对于区间求和，当然可以用循环进行累加求和，即每读入一个区间(a,b)，就在(a,b)上做循环累加。显然，这种暴力算法的时间复杂度为$O(n^2)$，用于解此题会出现超时的情况。\n通过分析不难看出，暴力算法之所以效率低下，是因为进行了多次重复的累计求和。如果能用一个数组rangeSum保存从数组开始到某个元素为止的累加，就可以直接计算出区间和。例如，rangeSum[b]表示从0到b的元素的累加，rangeSum[a]表示从0到a的元素的累加，那么用rangeSum[b] - rangeSum[a - 1]（要注意处理a为0的情形）就得到了(a,b)上的区间和。这种方法被称为前缀和，若采用前缀和，则求区间和的时间复杂度降为$O(1)$，整体的时间复杂度降为$O(n)$。\n3.解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[] nums = new int[n]; int[] rangeSum = new int[n];// 前缀和数组 int sum = 0; for(int i = 0; i \u0026lt; n; i++) { int val = scanner.nextInt(); sum += val;// 读取元素的同时累加计算前缀和 nums[i] = val; rangeSum[i] = sum; } while(scanner.hasNextInt()) { int a = scanner.nextInt(); int b = scanner.nextInt(); if(a \u0026gt; 0) { System.out.println(rangeSum[b] - rangeSum[a - 1]); } else { // 注意处理a为0的特殊情形 System.out.println(rangeSum[b]); } } scanner.close(); } } 开发商购买土地 1.题目描述 在一个城市区域内，被划分成了n*m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A公司和B公司，希望购买这个城市区域的土地。 现在，需要将这个城市区域的所有区块分配给A公司和B公司。\n然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。 为了确保公平竞争，你需要找到一种分配方式，使得A公司和B公司各自的子区域内的土地总价值之差最小。 注意：区块不可再分。\n输入描述\n第一行输入两个正整数，代表n和m。 接下来的n行，每行输出m个正整数。\n输出描述\n请输出一个整数，代表两个子区域内土地总价值之间的最小差距。\n输入示例\n1 2 3 4 3 3 1 2 3 2 1 3 1 2 3 输出示例\n1 0 提示信息\n1.如果将区域按照如下方式划分：\n1 2 3 1 2 | 3 2 1 | 3 1 2 | 3 两个子区域内土地总价值之间的最小差距可以达到0。\n2.数据范围\n1 \u0026lt;= n, m \u0026lt;= 100；\nn和m不同时为 1。\n题目链接：44.开发商购买土地｜代码随想录\n2.算法分析 由于矩阵只能按行或者列分为两部分，因此实际上我们要处理的是一维数组而非二维矩阵。以按行划分为例，用一个数组来保存各个行上元素的和，那么题目就转化为了将该数组划分为两个子区间，并使得这两个子区间上的元素和的差值最小，故本题实际上是一种区间和问题的变体。要计算两个子区间上元素和的差值，就可以借助前缀和。若A公司的区域范围是行0到行i，B公司的区域范围是行i+1到行n-1，那么A公司的土地价值总和就是行和数组区间(0,i)上的元素和，即行和前缀和数组的元素i的值，类似的，B公司的土地价值总和就是行和数组区间(i+1, n-1)上的元素和，即行和前缀和数组的元素n-1减去元素i（按行计算的总土地价值减去A公司的土地价值总和）。\n综上所述，算法分为两步：\n第一步，计算矩阵的行和前缀和数组和列和前缀和数组；\n第二步，计算按行划分的最小价值差和计算按列划分的最小价值差，二者进行比较得到整体的最小价值差。\n第一步的时间复杂度是$O(n * m)$，第二步的时间复杂度是$O(n+m)$，总体时间复杂度为$O(n * m)$。\n3.解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int m = scanner.nextInt(); int[][] land = new int[n][m]; int[] rowRangeSum = new int[n];// 行和前缀和数组 int[] colRangeSum = new int[m];// 列和前缀和数组 // 读取元素并计算行和前缀和 for(int i = 0; i \u0026lt; n; i++) { int r_sum = 0;// 行和 for(int j = 0; j \u0026lt; m; j++) { int val = scanner.nextInt(); land[i][j] = val; r_sum += val; } if(i == 0 ) { rowRangeSum[i] = r_sum; } else { rowRangeSum[i] = rowRangeSum[i - 1] + r_sum;// 行和前缀和 } } // 计算列和前缀和 for(int j = 0; j \u0026lt; m; j++) { int c_sum = 0;// 列和 for(int i = 0; i \u0026lt; n; i++) { c_sum += land[i][j]; } if(j == 0) { colRangeSum[j] = c_sum; } else { colRangeSum[j] = colRangeSum[j - 1] + c_sum;// 列和前缀和 } } // 计算按行划分的最小价值差 int min_row_diff = Integer.MAX_VALUE; for(int i = 0; i \u0026lt; n - 1; i++) { int val_a = rowRangeSum[i]; int val_b = rowRangeSum[n - 1] - val_a; int diff = Math.abs(val_b - val_a); if(diff \u0026lt; min_row_diff) { min_row_diff = diff; } } // 计算按列划分的最小价值差 int min_col_diff = Integer.MAX_VALUE; for(int j = 0; j \u0026lt; m - 1; j++) { int val_a = colRangeSum[j]; int val_b = colRangeSum[m - 1] - val_a; int diff = Math.abs(val_b - val_a); if(diff \u0026lt; min_col_diff) { min_col_diff = diff; } } // 计算整体的最小价值差 int min_val_diff = Math.min(min_row_diff, min_col_diff); System.out.println(min_val_diff); scanner.close(); } } ","date":"2025-03-21T23:24:00+08:00","permalink":"https://noahzyl.github.io/p/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-2-leetcode209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84leetcode59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-ii%E5%8C%BA%E9%97%B4%E5%92%8C%E5%BC%80%E5%8F%91%E5%95%86%E8%B4%AD%E4%B9%B0%E5%9C%9F%E5%9C%B0/","title":"算法训练 2｜ LeetCode209 长度最小的子数组、LeetCode59 螺旋矩阵 II、区间和、开发商购买土地"},{"content":"704 二分查找 1.题目描述 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例 1:\n1 2 3 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2:\n1 2 3 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示：\n你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 2.算法分析 这是一道最“原生”的二分查找题目，直接使用二分查找算法从序列中搜索目标元素即可（之所以称为“原生”是因为这道题的算法相较C++的upper_bound和lower_bound函数来说要简单一些）。\n所谓二分，就是在每一次搜索中取搜索区间中间的元素，和目标值进行比较，根据中间元素和目标值的大小关系判断目标值是位于中间元素的左侧、右侧还是恰好就是中间元素。由于每次都会将搜索空间减半，因此时间复杂度为$O(\\text{log}\\ n)$。同时，二分查找的算法逻辑决定了使用二分查找的前提是序列必须有序，例如本题中的序列是升序的，因此，若目标值小于中间元素，则目标值在左子区间，若目标值大于中间元素，则目标值在右子区间，若二者相同，则找到目标值。\n实现二分查找算法的关键在于对搜索区间边界的处理，用left表示左边界，用right表示右边界，用middle表示中间位置，在算法中：\nwhile循环的条件是left \u0026lt; right还是left \u0026lt;= right？ 当nums[middle] \u0026gt; target时，目标值在左子区间，此时需要更新搜索区间的右边界，那么应该是right = middle还是right = middle - 1？ 实际上，边界的处理取决于搜索区间的表示方式，常见的有左闭右开和左闭右闭两种（个人推荐凡是涉及到区间的表示都统一使用左闭右开，在计算并区间和区间长度时都很方便）。\n左闭右开区间：\n在左闭右开的区间表示下，合法的搜索范围应是left \u0026lt; right，当left == right时，区间内没有元素，目标值不在序列中，while循环应退出。当nums[middle] \u0026gt; target时，由于middle已经被搜索过，因此下一次的搜索范围将不包含middle，下一次搜索中right恰好与middle相同，故令right = middle。\n左闭右闭区间：\n在左闭右闭的区间表示下，合法的搜索范围应是left \u0026lt;= right，当left == right时，区间内仅有一个元素。当nums[middle] \u0026gt; target时，由于middle已经被搜索过，因此下一次的搜索范围将不包含middle，又注意到right也在搜索范围内，故令right = middle - 1。\n要注意的是，不论使用哪一种区间表示，每一次更新边界时都必须将middle去除，否则当搜索区间内只有一个元素时，就会陷入死循环。\n综上所述，在实现二分查找算法时，需要注意两点：第一是保持搜索区间表示的一致性和合法性，第二是注意每次更新边界时都必须去除此次搜索区间的中间位置。\n3.解题代码 左闭右开区间：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int search(int[] nums, int target) { int l = 0; // 初始左边界 int r = nums.length; // 初始右边界 while(l \u0026lt; r) { // 为了防止溢出，采取左边界+区间长度一半的方式确定中间位置 int mid = l + (r - l) / 2; // 在左闭右开的表示下，区间长度是r - l if(nums[mid] \u0026gt; target) { // 目标值在左子区间 r = mid; // 更新右边界（去除mid） } else if(nums[mid] \u0026lt; target) { // 目标值在右子区间 l = mid + 1; // 更新左边界（去除mid） } else { return mid; } } return -1; } } 左闭右闭区间：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int search(int[] nums, int target) { int l = 0; // 初始左边界 int r = nums.length - 1; // 初始右边界 while(l \u0026lt;= r) { int mid = l + (r - l + 1) / 2;// 在左闭右闭的表示下，区间长度是r - l + 1 if(nums[mid] \u0026gt; target) { r = mid - 1; } else if(nums[mid] \u0026lt; target) { l = mid + 1; } else { return mid; } } return -1; } } 27 移除元素 1.题目描述 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。\n假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行以下操作：\n更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。nums 的其余元素和 nums 的大小并不重要。 返回 k。 用户评测：\n评测机将使用以下代码测试您的解决方案：\n1 2 3 4 5 6 7 8 9 10 11 12 int[] nums = [...]; // 输入数组 int val = ...; // 要移除的值 int[] expectedNums = [...]; // 长度正确的预期答案。 // 它以不等于 val 的值排序。 int k = removeElement(nums, val); // 调用你的实现 assert k == expectedNums.length; sort(nums, 0, k); // 排序 nums 的前 k 个元素 for (int i = 0; i \u0026lt; actualLength; i++) { assert nums[i] == expectedNums[i]; } 如果所有的断言都通过，你的解决方案将会 通过。\n示例 1：\n1 2 3 4 输入： nums = [3,2,2,3], val = 3 输出： 2, nums = [2,2,_,_] 解释： 你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。 你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。 示例 2：\n1 2 3 4 5 输入： nums = [0,1,2,2,3,0,4,2], val = 2 输出： 5, nums = [0,1,4,0,3,_,_,_] 解释： 你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。 注意这五个元素可以任意顺序返回。 你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。 提示：\n0 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 50 0 \u0026lt;= val \u0026lt;= 100 2.算法分析 注意到序列的长度不超过100，因此暴力算法对该题目而言也是可行的，即遍历序列，若发现需要去除的元素，则从序列中去除该元素，显然，暴力算法的时间复杂度为$O(n^2)$（现代计算机一秒大约能执行$10^8$条基本语句，当$n$取100时，基本语句的执行次数为$10^4$，还是能在一秒内执行完毕的）。\n可以看到，在暴力算法中，两层遍历分别执行了寻找新数组中的元素（即不等于val的元素）和移动元素两种操作。那么，我们可以在一次遍历中同时完成寻找新数组中的元素和移动元素的操作吗？答案是肯定的，只需要用双指针法即可：\nfast指针用于寻找新数组中的元素； slow指针用于表示元素在新数组中的索引。 由此，我们就可以用一次遍历就完成所有的操作，时间复杂度简化为$O(n)$。\n3.解题代码 暴力算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int removeElement(int[] nums, int val) { int k = nums.length;// 初始时假设所有元素都和val不同 // 注意，由于会删除元素，因此序列的长度是会变化的 for(int i = 0; i \u0026lt; k; i++) { if(nums[i] == val) { for(int j = i; j \u0026lt; k - 1; j++) { nums[j] = nums[j + 1]; } k--; } // 考虑到可能会出现连续几个val，因此需要检查一下在元素前移后，i处的元素是否是val // 若i处的元素是val，则下一次还需要从现在的i处开始遍历元素 if(nums[i] == val) { i--; } } return k; } } 双指针法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int removeElement(int[] nums, int val) { int fast = 0; int slow = 0; for(; fast \u0026lt; nums.length; fast++) { if(nums[fast] != val) { // 判断是否是新数组中的元素 nums[slow] = nums[fast];// 将元素放到slow指向的位置 slow++;// 将slow向前移动一位 } } return slow; } } ","date":"2025-03-21T23:19:31+08:00","permalink":"https://noahzyl.github.io/p/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-1leetcode704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEleetcode27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/","title":"算法训练 1｜LeetCode704 二分查找、LeetCode27 移除元素"}]